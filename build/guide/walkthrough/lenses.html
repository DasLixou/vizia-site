<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../vizia_logo.svg" />
		<meta name="viewport" content="width=device-width" />
		<title>Vizia</title>
		<link rel="preconnect" href="https://api.fonts.coollabs.io" crossorigin />
		<link
			href="https://api.fonts.coollabs.io/css2?family=Rubik:wght@400;600;800&display=swap"
			rel="stylesheet"
		/>

		<meta http-equiv="content-security-policy" content="">
		<link href="../../_app/immutable/assets/_layout-c35e2532.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/_layout-3afad862.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/_page-470d98af.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/SvelteMarkdown-a075e35a.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/start-42262e0c.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index-d8dd06c7.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/singletons-f2328797.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/control-f5b05b5f.js">
		<link rel="modulepreload" href="../../_app/immutable/components/pages/_layout.svelte-8511c5ad.js">
		<link rel="modulepreload" href="../../_app/immutable/modules/pages/_layout.ts-9cbb603b.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/_layout-da46b06b.js">
		<link rel="modulepreload" href="../../_app/immutable/components/pages/guide/_layout.svelte-8ad1077b.js">
		<link rel="modulepreload" href="../../_app/immutable/modules/pages/guide/_layout.ts-4b35054f.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index-1885ff30.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/_layout-bb4149a0.js">
		<link rel="modulepreload" href="../../_app/immutable/components/pages/guide/_...docsPage_/_page.svelte-674c16ea.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/SvelteMarkdown-ed02a9e5.js">
		<link rel="modulepreload" href="../../_app/immutable/modules/pages/guide/_...docsPage_/_page.ts-317334f4.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/_page-160bb0e3.js">
	</head>

	<body data-sveltekit-prefetch>
		<div style="display: contents">


<div class="app svelte-jyuwmr"><nav class="header svelte-vg67y7" aria-label="Primary"><a class="logo-wrapper svelte-vg67y7" href="/"><img src="/vizia_logo.svg" class="logo svelte-vg67y7" alt="Vite Logo">
		<p class="svelte-vg67y7">Vizia</p></a>

	<div class="links-wrapper svelte-vg67y7"><a href="https://github.com/vizia/vizia" target="_blank" rel="noreferrer" class="svelte-vg67y7"><img src="/Github.svg" class="logo svelte-vg67y7" alt="Github Logo"></a>
		<a href="https://discord.gg/e3k9TZqrps" target="_blank" rel="noreferrer" class="svelte-vg67y7"><img src="/Discord.svg" class="logo svelte-vg67y7" alt="Discord Logo"></a></div>

	<div class="nav-wrapper svelte-vg67y7"><a href="/tutorial" class="svelte-vg67y7">Tutorial</a>
		<div class="dropdown-title svelte-qylgd5"><p>Docs</p></div>

<div class="dropdown-contents svelte-qylgd5"><a href="/guide" class="svelte-qylgd5">Guide</a><a href="/examples" class="svelte-qylgd5">Examples</a>
</div>
		<a href="/blog" class="svelte-vg67y7">Blog</a>
		<a href="/faq" class="svelte-vg67y7">FAQ</a>
		<a href="/about" class="svelte-vg67y7">About</a></div>
</nav>

	<main class="svelte-jyuwmr"><nav class="table-of-contents svelte-1gjfv2a"><h2 class="svelte-1gjfv2a">introduction</h2>
			<ol class="svelte-1gjfv2a"><li class="svelte-1gjfv2a"><a href="/guide/introduction/foreword" class=" svelte-1gjfv2a">Foreword</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/introduction/getting_started" class=" svelte-1gjfv2a">Getting started</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/introduction/quickstart" class=" svelte-1gjfv2a">Quickstart</a>
					</li></ol>
			<div class="space svelte-1gjfv2a"></div><h2 class="svelte-1gjfv2a">walkthrough</h2>
			<ol class="svelte-1gjfv2a"><li class="svelte-1gjfv2a"><a href="/guide/walkthrough/introduction" class=" svelte-1gjfv2a">Introduction</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/walkthrough/lenses" class="active svelte-1gjfv2a">Lenses</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/walkthrough/styling" class=" svelte-1gjfv2a">Styling</a>
					</li></ol>
			<div class="space svelte-1gjfv2a"></div><h2 class="svelte-1gjfv2a">basic</h2>
			<ol class="svelte-1gjfv2a"><li class="svelte-1gjfv2a"><a href="/guide/basic/application" class=" svelte-1gjfv2a">Application</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/views" class=" svelte-1gjfv2a">Views</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/styling" class=" svelte-1gjfv2a">Styling</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/layout" class=" svelte-1gjfv2a">Layout</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/models" class=" svelte-1gjfv2a">Models</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/binding" class=" svelte-1gjfv2a">Binding</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/events" class=" svelte-1gjfv2a">Events</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/custom_views" class=" svelte-1gjfv2a">Custom views</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/environment" class=" svelte-1gjfv2a">Environment</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/resources" class=" svelte-1gjfv2a">Resources</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/animation" class=" svelte-1gjfv2a">Animation</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/localization" class=" svelte-1gjfv2a">Localization</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/accessibility" class=" svelte-1gjfv2a">Accessibility</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/keymap" class=" svelte-1gjfv2a">Keymap</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/list" class=" svelte-1gjfv2a">List</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/overview" class=" svelte-1gjfv2a">Overview</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/view_event_handling" class=" svelte-1gjfv2a">View event handling</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/view_model_data" class=" svelte-1gjfv2a">View model data</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/basic/view_tree" class=" svelte-1gjfv2a">View tree</a>
					</li></ol>
			<div class="space svelte-1gjfv2a"></div><h2 class="svelte-1gjfv2a">advanced</h2>
			<ol class="svelte-1gjfv2a"><li class="svelte-1gjfv2a"><a href="/guide/advanced/custom_views" class=" svelte-1gjfv2a">Custom views</a>
					</li><li class="svelte-1gjfv2a"><a href="/guide/advanced/localization" class=" svelte-1gjfv2a">Localization</a>
					</li></ol>
			<div class="space svelte-1gjfv2a"></div></nav>



<div class="on-this-page svelte-1x9dk3c"></div>

<div class="docs-content"><h1 id="all-about-lenses">All About Lenses</h1><p>You may have noticed something weird about the counter example.
Here's a zoomed-in view of the strange part:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-meta">#[derive(Lens)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppData</span> {
    number: <span class="hljs-type">i32</span>,
}

<span class="hljs-comment">// ...</span>

        Binding::<span class="hljs-title function_ invoke__">new</span>(cx, AppData::number, |cx, number| {

<span class="hljs-comment">// ...</span><!-- HTML_TAG_END --></code></pre><p>What does it mean to reference a field of a struct like that?
Here's a hint: this isn't usually valid Rust.
When we say <code>AppData::number</code>, we're referring to a <em>static variable</em> defined by <code>derive(Lens)</code> with the same name as the field.
This variable is, surprise, a lens!</p><p>Lenses are property getter objects, allowing you to "select" some part of the model and inspect it at will.
These objects are passed to bindings to let them store the fact that you would like to bind to something specific, instead of having to rebuild the descendants of a binding every time any aspect of the model changes.</p><!-- HTML_TAG_START --><!-- Lenses are also very cheap, since they don't store any data of their own, just how to access some data.
This means you can pass lenses around freely without worrying about lifetimes, ownership, or cloning. -->

<!-- HTML_TAG_END --><p>Now, let's look at the other strange part of the example:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-comment">// ...</span>

        Binding::<span class="hljs-title function_ invoke__">new</span>(cx, AppData::number, |cx, number| {
            <span class="hljs-comment">// The value we&#x27;re passed is almost, but not quite,</span>
            <span class="hljs-comment">// the number we care about. Let&#x27;s get it!</span>
            <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = *number.<span class="hljs-title function_ invoke__">get</span>(cx);

            <span class="hljs-comment">// Build our second view</span>
            Label::<span class="hljs-title function_ invoke__">new</span>(cx, &amp;number.<span class="hljs-title function_ invoke__">to_string</span>());
        });

<span class="hljs-comment">// ...</span><!-- HTML_TAG_END --></code></pre><p>What, exactly, is the value that gets passed to the binding's closure?
It is, surprise, the same lens we passed in!
Lenses come in with a method to pull their data out of the associated model.
<code>*number.get(cx)</code> is equivalent to the following: <code>cx.data::&lt;AppData>().unwrap().number</code>.</p><h2 id="lenses-under-the-hood">Lenses Under the Hood</h2><p>So far, we've only talked about the lenses that are created through the Lens derive macro.
There are other kinds of lenses!</p><p>The lens trait declaration looks something like this:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Lens</span>: <span class="hljs-symbol">&#x27;static</span> + <span class="hljs-built_in">Clone</span> {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Source</span>;
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">view</span>&lt;O, F: <span class="hljs-title function_ invoke__">FnOnce</span>(<span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">Self</span>::Target&gt;) <span class="hljs-punctuation">-&gt;</span> O&gt;(&amp;<span class="hljs-keyword">self</span>, source: &amp;<span class="hljs-keyword">Self</span>::Source, map: F) <span class="hljs-punctuation">-&gt;</span> O;
}<!-- HTML_TAG_END --></code></pre><p>As you can see, every lens has two associated types, a Source and a Target.
The view function's job is, more or less, to transform a Source reference into a Target reference.
We'll get into why its signature is more complicated than that in a second!
For our <code>AppData::number</code> lens, we have <code>Source = AppData</code> and <code>Target = i32</code>.</p><p>The <code>get(cx)</code> function, as we saw before, grabs the source reference out of the current context (finds the most recent ancestor in the tree that has an appropriate model built into it).
Then, it runs <code>view</code> to transform a source reference into a target reference, and finally, clones the data out of reference in order to return it.
It may look like <code>get(cx)</code> returns a reference since we're dereferencing it, but the value returned actually has ownership over the data.</p><h2 id="even-more-lenses-then">Even More Lenses: Then</h2><p>Let's say you have the following setup:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-meta">#[derive(Lens, Default)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppData</span> {
    <span class="hljs-keyword">pub</span> some_struct: SomeStruct
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppData</span> {}

<span class="hljs-meta">#[derive(Lens, Default)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SomeStruct</span> {
    <span class="hljs-keyword">pub</span> field1: <span class="hljs-type">i32</span>,
    <span class="hljs-keyword">pub</span> field2: <span class="hljs-type">i32</span>,
}

<span class="hljs-comment">// ...</span>

    AppData::<span class="hljs-title function_ invoke__">default</span>().<span class="hljs-title function_ invoke__">build</span>(cx);

<span class="hljs-comment">// ...</span><!-- HTML_TAG_END --></code></pre><p>So we have an AppData built as a model in our tree, and it has a SomeStruct as a member.
How can we bind just to <code>field1</code>, without rebuilding the tree when <code>field2</code> is changed?
We have two lenses, <code>AppData::some_struct</code> (which has <code>Source = AppState</code> and <code>Target = SomeStruct</code>) and <code>SomeStruct::field1</code> (which has <code>Source = SomeStruct</code> and <code>Target = i32</code>), and we would like to somehow join them together.</p><p>The syntax for this is <code>AppData::some_struct.then(SomeStruct::field1)</code>.
This creates a <code>Then</code> lens, a lens which combines two other lenses to get the output of the second lens given the input of the first lens.
This lens has <code>Source = AppData</code> and <code>Target = i32</code>, so it can be used just like you would any other lens, including as part of another Then lens!
For example, <code>Binding::new(cx, AppData::some_struct.then(SomeStruct::field1), |cx, lens| { ... })</code>.</p><h2 id="even-more-lenses-map">Even More Lenses: Map</h2><p>Let's say you have the following setup:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-meta">#[derive(Lens)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppData</span> {
    <span class="hljs-keyword">pub</span> my_list: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;,
}<!-- HTML_TAG_END --></code></pre><p>...and you want to be able to bind to <em>just the length</em> of the list.
You can do that by creating a Map lens, or a lens that can compute arbitrary data for its target instead of just referencing a part of its source.
It looks like this: <code>AppData::my_list.map(|my_list| my_list.len())</code>.
This creates a lens with <code>Source = AppData</code> and <code>Target = usize</code>.
Any binding using this lens will only rebuild its children when it detects the length of the list has changed - not any of its contents!</p><p>Note that since map lenses contain a closure, they are not <code>Copy</code>.
You'll have to explicitly clone them whenever you want to pass them around.</p><h2 id="bindings-under-the-hood">Bindings Under the Hood</h2><p>Let's take a short detour to talk about why your choice of lens matters.
First, when you build a binding, the lens you pass in must have a source type which implements <code>Model</code> and a target type that implements a different trait, <code>Data</code>.
We haven't seen <code>Data</code> yet, but it is very simple: here is its full definition:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Data</span>: <span class="hljs-symbol">&#x27;static</span> + <span class="hljs-built_in">Clone</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">same</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;
}<!-- HTML_TAG_END --></code></pre><p>When you have an object that is <code>Data</code>, you can clone it and you can check if it's the <code>same</code> as some other data.
This is everything that is needed for the entire lifecycle for bindings:</p><ul><li>When a binding is created, Vizia stores a clone of the data the lens computes
            </li><li>After any change is made to any part of the model, Vizia loops through all bindings and recomputes the data through the lens
            </li><li>If the data presently in the model is different from the newly computed data, the binding is rerun and the stored data is updated.
            </li></ul><p>This is why it matters which lenses you use!
The data you bind to must be small, since it will be cloned whenever it changes, and the lens computation must be cheap, since it will be done whenever <em>anything</em> in the app changes!</p><h2 id="property-bindings">Property Bindings</h2><p>Bonus round!
Now that you understand both lenses and styling, you can use a more efficient but more limited form of binding which doesn't rebuild any of the tree but can instead set style attributes.
Take a look at this:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START -->        HStack::<span class="hljs-title function_ invoke__">new</span>(cx, |cx| {
            Label::<span class="hljs-title function_ invoke__">new</span>(cx, <span class="hljs-string">&quot;Label 1&quot;</span>).<span class="hljs-title function_ invoke__">space</span>(Units::Auto);
            Label::<span class="hljs-title function_ invoke__">new</span>(cx, <span class="hljs-string">&quot;Label 2&quot;</span>).<span class="hljs-title function_ invoke__">space</span>(Units::Auto);
        })
            .<span class="hljs-title function_ invoke__">bind</span>(AppData::spacing, |handle, spacing| {
                <span class="hljs-keyword">let</span> <span class="hljs-variable">col</span> = Units::<span class="hljs-title function_ invoke__">Pixels</span>(*spacing.<span class="hljs-title function_ invoke__">get</span>(handle.cx));
                handle.<span class="hljs-title function_ invoke__">col_between</span>(col);
            });<!-- HTML_TAG_END --></code></pre><p>Assuming that <code>spacing</code> is an <code>f32</code>, this should automatically bind the space between the two labels (the width of the column between the HStack's children) to that part of the model.
This works by creating a regular binding with no children whose builder closure has a reference to another part of the tree.</p><p>In the case that you have a lens whose Target is the same type as a property setter expects, you can pass the lens directly to the property setter as a shorthand, and it will do the above for you!</p>
</div></main>
</div>


		<script type="module" data-sveltekit-hydrate="1nzzqjv">
			import { start } from "../../_app/immutable/start-42262e0c.js";

			start({
				env: {},
				paths: {"base":"","assets":""},
				target: document.querySelector('[data-sveltekit-hydrate="1nzzqjv"]').parentNode,
				version: "1672787809266",
				hydrate: {
					node_ids: [0, 2, 10],
					data: [null,null,null],
					form: null
				}
			});
		</script>
	<script type="application/json" data-sveltekit-fetched data-url="/docs/guide/walkthrough/lenses.md">{"status":200,"statusText":"","headers":{},"body":"# All About Lenses\n\nYou may have noticed something weird about the counter example.\nHere's a zoomed-in view of the strange part:\n\n```rust\n#[derive(Lens)]\npub struct AppData {\n\tnumber: i32,\n}\n\n// ...\n\n\t\tBinding::new(cx, AppData::number, |cx, number| {\n\n// ...\n```\n\nWhat does it mean to reference a field of a struct like that?\nHere's a hint: this isn't usually valid Rust.\nWhen we say `AppData::number`, we're referring to a _static variable_ defined by `derive(Lens)` with the same name as the field.\nThis variable is, surprise, a lens!\n\nLenses are property getter objects, allowing you to \"select\" some part of the model and inspect it at will.\nThese objects are passed to bindings to let them store the fact that you would like to bind to something specific, instead of having to rebuild the descendants of a binding every time any aspect of the model changes.\n\n\u003C!-- Lenses are also very cheap, since they don't store any data of their own, just how to access some data.\nThis means you can pass lenses around freely without worrying about lifetimes, ownership, or cloning. -->\n\nNow, let's look at the other strange part of the example:\n\n```rust\n// ...\n\n\t\tBinding::new(cx, AppData::number, |cx, number| {\n\t\t\t// The value we're passed is almost, but not quite,\n\t\t\t// the number we care about. Let's get it!\n\t\t\tlet number = *number.get(cx);\n\n\t\t\t// Build our second view\n\t\t\tLabel::new(cx, &number.to_string());\n\t\t});\n\n// ...\n```\n\nWhat, exactly, is the value that gets passed to the binding's closure?\nIt is, surprise, the same lens we passed in!\nLenses come in with a method to pull their data out of the associated model.\n`*number.get(cx)` is equivalent to the following: `cx.data::\u003CAppData>().unwrap().number`.\n\n## Lenses Under the Hood\n\nSo far, we've only talked about the lenses that are created through the Lens derive macro.\nThere are other kinds of lenses!\n\nThe lens trait declaration looks something like this:\n\n```rust\npub trait Lens: 'static + Clone {\n    type Source;\n    type Target;\n\n    fn view\u003CO, F: FnOnce(Option\u003C&Self::Target>) -> O>(&self, source: &Self::Source, map: F) -> O;\n}\n```\n\nAs you can see, every lens has two associated types, a Source and a Target.\nThe view function's job is, more or less, to transform a Source reference into a Target reference.\nWe'll get into why its signature is more complicated than that in a second!\nFor our `AppData::number` lens, we have `Source = AppData` and `Target = i32`.\n\nThe `get(cx)` function, as we saw before, grabs the source reference out of the current context (finds the most recent ancestor in the tree that has an appropriate model built into it).\nThen, it runs `view` to transform a source reference into a target reference, and finally, clones the data out of reference in order to return it.\nIt may look like `get(cx)` returns a reference since we're dereferencing it, but the value returned actually has ownership over the data.\n\n## Even More Lenses: Then\n\nLet's say you have the following setup:\n\n```rust\n#[derive(Lens, Default)]\npub struct AppData {\n\tpub some_struct: SomeStruct\n}\n\nimpl Model for AppData {}\n\n#[derive(Lens, Default)]\npub struct SomeStruct {\n\tpub field1: i32,\n\tpub field2: i32,\n}\n\n// ...\n\n\tAppData::default().build(cx);\n\n// ...\n```\n\nSo we have an AppData built as a model in our tree, and it has a SomeStruct as a member.\nHow can we bind just to `field1`, without rebuilding the tree when `field2` is changed?\nWe have two lenses, `AppData::some_struct` (which has `Source = AppState` and `Target = SomeStruct`) and `SomeStruct::field1` (which has `Source = SomeStruct` and `Target = i32`), and we would like to somehow join them together.\n\nThe syntax for this is `AppData::some_struct.then(SomeStruct::field1)`.\nThis creates a `Then` lens, a lens which combines two other lenses to get the output of the second lens given the input of the first lens.\nThis lens has `Source = AppData` and `Target = i32`, so it can be used just like you would any other lens, including as part of another Then lens!\nFor example, `Binding::new(cx, AppData::some_struct.then(SomeStruct::field1), |cx, lens| { ... })`.\n\n## Even More Lenses: Map\n\nLet's say you have the following setup:\n\n```rust\n#[derive(Lens)]\npub struct AppData {\n\tpub my_list: Vec\u003Ci32>,\n}\n```\n\n...and you want to be able to bind to _just the length_ of the list.\nYou can do that by creating a Map lens, or a lens that can compute arbitrary data for its target instead of just referencing a part of its source.\nIt looks like this: `AppData::my_list.map(|my_list| my_list.len())`.\nThis creates a lens with `Source = AppData` and `Target = usize`.\nAny binding using this lens will only rebuild its children when it detects the length of the list has changed - not any of its contents!\n\nNote that since map lenses contain a closure, they are not `Copy`.\nYou'll have to explicitly clone them whenever you want to pass them around.\n\n## Bindings Under the Hood\n\nLet's take a short detour to talk about why your choice of lens matters.\nFirst, when you build a binding, the lens you pass in must have a source type which implements `Model` and a target type that implements a different trait, `Data`.\nWe haven't seen `Data` yet, but it is very simple: here is its full definition:\n\n```rust\npub trait Data: 'static + Clone {\n    fn same(&self, other: &Self) -> bool;\n}\n```\n\nWhen you have an object that is `Data`, you can clone it and you can check if it's the `same` as some other data.\nThis is everything that is needed for the entire lifecycle for bindings:\n\n- When a binding is created, Vizia stores a clone of the data the lens computes\n- After any change is made to any part of the model, Vizia loops through all bindings and recomputes the data through the lens\n- If the data presently in the model is different from the newly computed data, the binding is rerun and the stored data is updated.\n\nThis is why it matters which lenses you use!\nThe data you bind to must be small, since it will be cloned whenever it changes, and the lens computation must be cheap, since it will be done whenever _anything_ in the app changes!\n\n## Property Bindings\n\nBonus round!\nNow that you understand both lenses and styling, you can use a more efficient but more limited form of binding which doesn't rebuild any of the tree but can instead set style attributes.\nTake a look at this:\n\n```rust\n        HStack::new(cx, |cx| {\n            Label::new(cx, \"Label 1\").space(Units::Auto);\n            Label::new(cx, \"Label 2\").space(Units::Auto);\n        })\n            .bind(AppData::spacing, |handle, spacing| {\n                let col = Units::Pixels(*spacing.get(handle.cx));\n                handle.col_between(col);\n            });\n```\n\nAssuming that `spacing` is an `f32`, this should automatically bind the space between the two labels (the width of the column between the HStack's children) to that part of the model.\nThis works by creating a regular binding with no children whose builder closure has a reference to another part of the tree.\n\nIn the case that you have a lens whose Target is the same type as a property setter expects, you can pass the lens directly to the property setter as a shorthand, and it will do the above for you!\n"}</script>
	<script type="application/json" data-sveltekit-fetched data-url="/get-guides">{"status":200,"statusText":"","headers":{},"body":"{\"file_name\":\"guide\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide\",\"link\":\"/guide\",\"is_dir\":true,\"files\":[{\"file_name\":\"introduction\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/introduction\",\"link\":\"/guide/introduction\",\"is_dir\":true,\"files\":[{\"file_name\":\"Foreword\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/introduction/foreword.md\",\"link\":\"/guide/introduction/foreword\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":1}},{\"file_name\":\"Getting started\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/introduction/getting_started.md\",\"link\":\"/guide/introduction/getting_started\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":2}},{\"file_name\":\"Quickstart\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/introduction/quickstart.md\",\"link\":\"/guide/introduction/quickstart\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":3}}],\"meta\":{\"order\":1}},{\"file_name\":\"walkthrough\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/walkthrough\",\"link\":\"/guide/walkthrough\",\"is_dir\":true,\"files\":[{\"file_name\":\"Introduction\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/walkthrough/introduction.md\",\"link\":\"/guide/walkthrough/introduction\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Lenses\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/walkthrough/lenses.md\",\"link\":\"/guide/walkthrough/lenses\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Styling\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/walkthrough/styling.md\",\"link\":\"/guide/walkthrough/styling\",\"is_dir\":false,\"files\":[]}],\"meta\":{\"order\":1}},{\"file_name\":\"basic\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic\",\"link\":\"/guide/basic\",\"is_dir\":true,\"files\":[{\"file_name\":\"Application\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/application.md\",\"link\":\"/guide/basic/application\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":1}},{\"file_name\":\"Views\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/views.md\",\"link\":\"/guide/basic/views\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":2}},{\"file_name\":\"Styling\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/styling.md\",\"link\":\"/guide/basic/styling\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":3}},{\"file_name\":\"Layout\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/layout.md\",\"link\":\"/guide/basic/layout\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":4}},{\"file_name\":\"Models\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/models.md\",\"link\":\"/guide/basic/models\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":5}},{\"file_name\":\"Binding\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/binding.md\",\"link\":\"/guide/basic/binding\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":6}},{\"file_name\":\"Events\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/events.md\",\"link\":\"/guide/basic/events\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":7}},{\"file_name\":\"Custom views\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/custom_views.md\",\"link\":\"/guide/basic/custom_views\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":8}},{\"file_name\":\"Environment\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/environment.md\",\"link\":\"/guide/basic/environment\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":9}},{\"file_name\":\"Resources\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/resources.md\",\"link\":\"/guide/basic/resources\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":10}},{\"file_name\":\"Animation\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/animation.md\",\"link\":\"/guide/basic/animation\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":11}},{\"file_name\":\"Localization\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/localization.md\",\"link\":\"/guide/basic/localization\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":12}},{\"file_name\":\"Accessibility\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/accessibility.md\",\"link\":\"/guide/basic/accessibility\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":13}},{\"file_name\":\"Keymap\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/keymap.md\",\"link\":\"/guide/basic/keymap\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"List\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/list.md\",\"link\":\"/guide/basic/list\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Overview\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/overview.md\",\"link\":\"/guide/basic/overview\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"View event handling\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/view_event_handling.md\",\"link\":\"/guide/basic/view_event_handling\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"View model data\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/view_model_data.md\",\"link\":\"/guide/basic/view_model_data\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"View tree\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/view_tree.md\",\"link\":\"/guide/basic/view_tree\",\"is_dir\":false,\"files\":[]}],\"meta\":{\"order\":2}},{\"file_name\":\"advanced\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/advanced\",\"link\":\"/guide/advanced\",\"is_dir\":true,\"files\":[{\"file_name\":\"Custom views\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/advanced/custom_views.md\",\"link\":\"/guide/advanced/custom_views\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Localization\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/advanced/localization.md\",\"link\":\"/guide/advanced/localization\",\"is_dir\":false,\"files\":[]}],\"meta\":{\"order\":3}},{\"file_name\":\"SUMMARY\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/SUMMARY.md\",\"link\":\"/guide/SUMMARY\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Architecture\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/architecture.md\",\"link\":\"/guide/architecture\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Index\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/index.md\",\"link\":\"/guide/index\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Intro\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/intro.md\",\"link\":\"/guide/intro\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Prerequisites\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/prerequisites.md\",\"link\":\"/guide/prerequisites\",\"is_dir\":false,\"files\":[]}],\"meta\":{\"order\":1}}"}</script></div>
	</body>
</html>
