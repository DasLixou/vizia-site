<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../vizia_logo.svg" />
		<meta name="viewport" content="width=device-width" />
		<title>Vizia</title>
		<link rel="preconnect" href="https://api.fonts.coollabs.io" crossorigin />
		<link
			href="https://api.fonts.coollabs.io/css2?family=Rubik:wght@400;600;800&display=swap"
			rel="stylesheet"
		/>

		<meta http-equiv="content-security-policy" content="">
		<link href="../../_app/immutable/assets/_layout-c35e2532.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/_layout-a2820616.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/_page-470d98af.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/SvelteMarkdown-a075e35a.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/start-a91705ae.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index-d8dd06c7.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/singletons-f916f1fe.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/paths-b4419565.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/control-f5b05b5f.js">
		<link rel="modulepreload" href="../../_app/immutable/components/pages/_layout.svelte-8511c5ad.js">
		<link rel="modulepreload" href="../../_app/immutable/modules/pages/_layout.ts-9cbb603b.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/_layout-da46b06b.js">
		<link rel="modulepreload" href="../../_app/immutable/components/pages/guide/_layout.svelte-5e044d55.js">
		<link rel="modulepreload" href="../../_app/immutable/modules/pages/guide/_layout.ts-4b35054f.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index-1885ff30.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/_layout-bb4149a0.js">
		<link rel="modulepreload" href="../../_app/immutable/components/pages/guide/_...docsPage_/_page.svelte-6f6b4ca2.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/SvelteMarkdown-ed02a9e5.js">
		<link rel="modulepreload" href="../../_app/immutable/modules/pages/guide/_...docsPage_/_page.ts-317334f4.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/_page-160bb0e3.js">
	</head>

	<body data-sveltekit-prefetch>
		<div style="display: contents">


<div class="app svelte-jyuwmr"><nav class="header svelte-vg67y7" aria-label="Primary"><a class="logo-wrapper svelte-vg67y7" href="/"><img src="/vizia_logo.svg" class="logo svelte-vg67y7" alt="Vite Logo">
		<p class="svelte-vg67y7">Vizia</p></a>

	<div class="links-wrapper svelte-vg67y7"><a href="https://github.com/vizia/vizia" target="_blank" rel="noreferrer" class="svelte-vg67y7"><img src="/Github.svg" class="logo svelte-vg67y7" alt="Github Logo"></a>
		<a href="https://discord.gg/e3k9TZqrps" target="_blank" rel="noreferrer" class="svelte-vg67y7"><img src="/Discord.svg" class="logo svelte-vg67y7" alt="Discord Logo"></a></div>

	<div class="nav-wrapper svelte-vg67y7"><a href="/tutorial" class="svelte-vg67y7">Tutorial</a>
		<div class="dropdown-title svelte-qylgd5"><p>Docs</p></div>

<div class="dropdown-contents svelte-qylgd5"><a href="/guide" class="svelte-qylgd5">Guide</a><a href="/examples" class="svelte-qylgd5">Examples</a>
</div>
		<a href="/blog" class="svelte-vg67y7">Blog</a>
		<a href="/faq" class="svelte-vg67y7">FAQ</a>
		<a href="/about" class="svelte-vg67y7">About</a></div>
</nav>

	<main class="svelte-jyuwmr"><nav class="table-of-contents svelte-10wxvf6"><h2 class="svelte-10wxvf6">introduction</h2>
			<ol class="svelte-10wxvf6"><li class="svelte-10wxvf6"><a href="/guide/introduction/foreword" class=" svelte-10wxvf6">Foreword</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/introduction/getting_started" class=" svelte-10wxvf6">Getting started</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/introduction/quickstart" class=" svelte-10wxvf6">Quickstart</a>
					</li></ol>
			<div class="space svelte-10wxvf6"></div><h2 class="svelte-10wxvf6">walkthrough</h2>
			<ol class="svelte-10wxvf6"><li class="svelte-10wxvf6"><a href="/guide/walkthrough/introduction" class=" svelte-10wxvf6">Introduction</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/walkthrough/lenses" class=" svelte-10wxvf6">Lenses</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/walkthrough/styling" class=" svelte-10wxvf6">Styling</a>
					</li></ol>
			<div class="space svelte-10wxvf6"></div><h2 class="svelte-10wxvf6">basic</h2>
			<ol class="svelte-10wxvf6"><li class="svelte-10wxvf6"><a href="/guide/basic/application" class=" svelte-10wxvf6">Application</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/views" class=" svelte-10wxvf6">Views</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/styling" class=" svelte-10wxvf6">Styling</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/layout" class=" svelte-10wxvf6">Layout</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/models" class=" svelte-10wxvf6">Models</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/binding" class="active svelte-10wxvf6">Binding</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/events" class=" svelte-10wxvf6">Events</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/custom_views" class=" svelte-10wxvf6">Custom views</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/environment" class=" svelte-10wxvf6">Environment</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/resources" class=" svelte-10wxvf6">Resources</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/animation" class=" svelte-10wxvf6">Animation</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/localization" class=" svelte-10wxvf6">Localization</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/accessibility" class=" svelte-10wxvf6">Accessibility</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/keymap" class=" svelte-10wxvf6">Keymap</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/list" class=" svelte-10wxvf6">List</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/overview" class=" svelte-10wxvf6">Overview</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/view_event_handling" class=" svelte-10wxvf6">View event handling</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/view_model_data" class=" svelte-10wxvf6">View model data</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/basic/view_tree" class=" svelte-10wxvf6">View tree</a>
					</li></ol>
			<div class="space svelte-10wxvf6"></div><h2 class="svelte-10wxvf6">advanced</h2>
			<ol class="svelte-10wxvf6"><li class="svelte-10wxvf6"><a href="/guide/advanced/custom_views" class=" svelte-10wxvf6">Custom views</a>
					</li><li class="svelte-10wxvf6"><a href="/guide/advanced/localization" class=" svelte-10wxvf6">Localization</a>
					</li></ol>
			<div class="space svelte-10wxvf6"></div></nav>



<div class="on-this-page svelte-1x9dk3c"></div>

<div class="docs-content"><h1 id="data-binding">Data Binding</h1><p>Data binding is the concept of linking model data to views, so that when the model data is changed, the views observing this data update in response.</p><!-- HTML_TAG_START --><!-- Therefore, it is data binding which provides the mechanism for reactivity in Vizia. -->

<!-- HTML_TAG_END --><p>In Vizia, data binding is achieved through the use of lenses. A lens is an object which allows you to <em>select</em> some part of a model and inspect its value. These lens objects are then used to form a binding between views and these parts of the model, updating when only these specific parts have changed.</p><p>The <code>Lens</code> derive macro can be used to generate a lens for each field of a struct. These lenses can then be used to transform a reference to the struct into a reference to each of its fields. The generated lenses are given the same name as the field and placed in a module with the same name as the struct. For example, given the following definition of some model data:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-keyword">use</span> vizia::prelude::*;

<span class="hljs-meta">#[derive(Lens)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppData</span> {
    name: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppData</span> {}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    Application::<span class="hljs-title function_ invoke__">new</span>(|cx|{

    }).<span class="hljs-title function_ invoke__">run</span>();
}<!-- HTML_TAG_END --></code></pre><p>A lens to the <code>name</code> field is generated as <code>AppData::name</code>. We can then use this lens with the <code>Label</code> view to set up a binding between the label and the name field.</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-keyword">use</span> vizia::prelude::*;

<span class="hljs-meta">#[derive(Lens)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppData</span> {
    name: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppData</span> {}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    Application::<span class="hljs-title function_ invoke__">new</span>(|cx|{
        Label::<span class="hljs-title function_ invoke__">new</span>(cx, AppData::name);
    }).<span class="hljs-title function_ invoke__">run</span>();
}<!-- HTML_TAG_END --></code></pre><p>The <code>Label</code> view accepts a lens to any type which implements the <code>ToString</code> trait.</p><p>// end here</p><p>A lens is a type which implements the <code>Lens</code> trait, which has a <code>Source</code> associated type, a <code>Target</code> associated type, and a <code>view</code> method. There are a few different types of lenses, but the simplest type transforms a reference to the <code>Source</code> into a reference to the <code>Target</code>.</p><p>Let's see how this is used to bind a <code>Label</code> view to a string property in the model data.</p><p>Ths trait has a function which returns some data derived from the</p><p>This trait describes how to extract a reference to some part of the model data. For example, given a reference to the model data, a lens could</p><p>This trait defines a <code>Source</code> type and a <code>Target</code> type, and a <code>view</code> function which, given a reference to the source, returns some output .</p><h2 id="view-binding">View Binding</h2><p>Some views accept a <a href="#lenses">lens</a>, as well as a value, as an input. When provided a lens, the view sets up a binding to the data.</p><p>For example, the <code>Label</code> view accepts a lens to any type which implements <code>ToString</code>:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-meta">#[derive(Lens)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> {}

Application::<span class="hljs-title function_ invoke__">new</span>(|cx|{
    Label::<span class="hljs-title function_ invoke__">new</span>(cx, Person::name);
})
.<span class="hljs-title function_ invoke__">run</span>()<!-- HTML_TAG_END --></code></pre><p>Note the <code>Lens</code> derive, which allows us to bind to a field of the model data. When the <code>name</code> field changes, the text of the label updates to show the new value.</p><h2 id="the-binding-view">The <code>Binding</code> View</h2><p>There is a special container view in Vizia called the <code>Binding</code> view. This view binds to some data and will remove and then rebuild its contents if the data changes.</p><p>The following code produces the same result as passing the lens directly to the label, however, the binding view will rebuild the label when the name changes, which is unnecessary. The binding view is useful for <a href="#conditional-views">constructing views conditionally</a>.</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> {}

Application::<span class="hljs-title function_ invoke__">new</span>(|cx|{
    Binding::<span class="hljs-title function_ invoke__">new</span>(cx, Person::name, |cx, name|{
        Label::<span class="hljs-title function_ invoke__">new</span>(cx, &amp;name.<span class="hljs-title function_ invoke__">get</span>(cx));
    });
})
.<span class="hljs-title function_ invoke__">run</span>()<!-- HTML_TAG_END --></code></pre><h1 id="lenses">Lenses</h1><p>Vizia uses lenses to allow specifying a binding to a piece of model data:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-meta">#[derive(Lens)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> {}<!-- HTML_TAG_END --></code></pre><p>The <code>Lens</code> derive macro generates a type for each of the fields of the struct.</p><p>Then, a static instance of each type is created with the same name as the field, within a module with the same name as the struct.</p><p>For example, for the above model, a lens to the <code>name</code> field is created as <code>Person::name</code>.</p><p>Each generated type implements the <code>Lens</code> trait, which looks something like this:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Lens</span> {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Source</span>;
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">view</span>(&amp;<span class="hljs-keyword">self</span>, &amp;<span class="hljs-keyword">Self</span>::Source) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target;
}<!-- HTML_TAG_END --></code></pre><blockquote><p>NOTE - The above code is a simplification.</p></blockquote><p>The view method of the lens takes a reference to a <code>Source</code> type and produces a reference to a <code>Target</code> type. For the <code>Person::name</code> lens, the source is <code>Person</code> and the target is <code>String</code>. The view method, given a reference to <code>Person</code>, returns a reference to the <code>name</code>.</p><h1 id="lens-map">Lens Map</h1><p>The <code>map()</code> method on a lens can be used to derive data from the target of the lens. This is useful for when the lens target is not the right type for the binding, but a value of the correct type can be derived from it.</p><p>For example, let's say we have some string data representing a name in our model, but we only want to display the first letter within a label:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-keyword">use</span> vizia::prelude::*;

<span class="hljs-meta">#[derive(Lens)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppData</span> {
    <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppData</span> {}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    Application::<span class="hljs-title function_ invoke__">new</span>(|cx|{

        AppData {
            name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;John Doe&quot;</span>),
        }.<span class="hljs-title function_ invoke__">build</span>(cx);

        Label::<span class="hljs-title function_ invoke__">new</span>(cx, AppData::name.<span class="hljs-title function_ invoke__">map</span>(|name| &amp;name[<span class="hljs-number">0</span>]));
    })
    .<span class="hljs-title function_ invoke__">inner_size</span>((<span class="hljs-number">400</span>, <span class="hljs-number">100</span>))
    .<span class="hljs-title function_ invoke__">run</span>();
}<!-- HTML_TAG_END --></code></pre><blockquote><p>Note that in this example we're assuming that the string is not empty.</p></blockquote><p>&lt;img src="../docs_img/stylesheet.png alt="" width="400"/></p><p>Now when the name field of the model changes the label will update to display the new first letter.</p><h1 id="property-binding">Property Binding</h1><p>A property binding updates just the style and layout properties of view in response to model data changes, instead of rebuilding the entire view. Most view modifiers accept a lens as input, which sets up a binding to the target data.</p><p>For example, we can bind the background color of a view, in this case a label, to a color property in the model data using a lens:</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-keyword">use</span> vizia::prelude::*;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppData</span> {
    color: Color,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppData</span> {}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    Application::<span class="hljs-title function_ invoke__">new</span>(|cx|{
        Label::<span class="hljs-title function_ invoke__">new</span>(cx, <span class="hljs-string">&quot;Colorful&quot;</span>)
            .<span class="hljs-title function_ invoke__">background_color</span>(AppData::color);
    }).<span class="hljs-title function_ invoke__">run</span>();
}<!-- HTML_TAG_END --></code></pre><p>Most modifiers accept a lens to a type which can be converted to the expected type. For example, the <code>text</code> modifier accepts a lens to any value which implements <code>ToString</code>.</p><h1 id="conditional-views">Conditional Views</h1><p>Using a <code>Binding</code> view a regular <code>if</code> statement can be used to conditionally rebuild views.</p><p>In the following example, a label view is built into the tree when a boolean state is true, else the view is removed from the tree.</p><pre class="rust"><code class="language-rust"><!-- HTML_TAG_START --><span class="hljs-keyword">use</span> vizia::prelude::*;

<span class="hljs-meta">#[derive(Lens)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppData</span> {
    show_view: <span class="hljs-type">bool</span>,
}

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">AppEvent</span> {
    ToggleShowView,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AppData</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">event</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, cx: &amp;<span class="hljs-keyword">mut</span> Context, event: &amp;<span class="hljs-keyword">mut</span> Event) {
        event.<span class="hljs-title function_ invoke__">map</span>(|app_event, _| <span class="hljs-keyword">match</span> app_event {
            AppEvent::ToggleShowView =&gt; <span class="hljs-keyword">self</span>.show_view ^= <span class="hljs-literal">true</span>,
        });
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    Application::<span class="hljs-title function_ invoke__">new</span>(|cx|{

        AppData {
            show_view: <span class="hljs-literal">false</span>,
        }.<span class="hljs-title function_ invoke__">build</span>(cx);

        Label::<span class="hljs-title function_ invoke__">new</span>(cx, <span class="hljs-string">&quot;Show View&quot;</span>)
            .<span class="hljs-title function_ invoke__">on_press</span>(|cx| cx.<span class="hljs-title function_ invoke__">emit</span>(AppEvent::ToggleShowView));

        Binding::<span class="hljs-title function_ invoke__">new</span>(cx, AppData::show_view, |cx, show|{
            <span class="hljs-keyword">if</span> show.<span class="hljs-title function_ invoke__">get</span>(cx) {
                Label::<span class="hljs-title function_ invoke__">new</span>(cx, <span class="hljs-string">&quot;Surprise!&quot;</span>);
            }
        });
    })
    .<span class="hljs-title function_ invoke__">inner_size</span>((<span class="hljs-number">400</span>, <span class="hljs-number">100</span>))
    .<span class="hljs-title function_ invoke__">run</span>();
}<!-- HTML_TAG_END --></code></pre>
</div></main>
</div>


		<script type="module" data-sveltekit-hydrate="6szyf3">
			import { start } from "../../_app/immutable/start-a91705ae.js";

			start({
				env: {},
				paths: {"base":"","assets":""},
				target: document.querySelector('[data-sveltekit-hydrate="6szyf3"]').parentNode,
				version: "1672790838751",
				hydrate: {
					node_ids: [0, 2, 10],
					data: [null,null,null],
					form: null
				}
			});
		</script>
	<script type="application/json" data-sveltekit-fetched data-url="/docs/guide/basic/binding.md">{"status":200,"statusText":"","headers":{},"body":"---\norder: 6\n---\n\n# Data Binding\n\nData binding is the concept of linking model data to views, so that when the model data is changed, the views observing this data update in response.\n\n\u003C!-- Therefore, it is data binding which provides the mechanism for reactivity in Vizia. -->\n\nIn Vizia, data binding is achieved through the use of lenses. A lens is an object which allows you to _select_ some part of a model and inspect its value. These lens objects are then used to form a binding between views and these parts of the model, updating when only these specific parts have changed.\n\nThe `Lens` derive macro can be used to generate a lens for each field of a struct. These lenses can then be used to transform a reference to the struct into a reference to each of its fields. The generated lenses are given the same name as the field and placed in a module with the same name as the struct. For example, given the following definition of some model data:\n\n```rust\nuse vizia::prelude::*;\n\n#[derive(Lens)]\npub struct AppData {\n    name: String,\n}\n\nimpl Model for AppData {}\n\nfn main() {\n    Application::new(|cx|{\n\n    }).run();\n}\n```\n\nA lens to the `name` field is generated as `AppData::name`. We can then use this lens with the `Label` view to set up a binding between the label and the name field.\n\n```rust\nuse vizia::prelude::*;\n\n#[derive(Lens)]\npub struct AppData {\n    name: String,\n}\n\nimpl Model for AppData {}\n\nfn main() {\n    Application::new(|cx|{\n        Label::new(cx, AppData::name);\n    }).run();\n}\n```\n\nThe `Label` view accepts a lens to any type which implements the `ToString` trait.\n\n// end here\n\nA lens is a type which implements the `Lens` trait, which has a `Source` associated type, a `Target` associated type, and a `view` method. There are a few different types of lenses, but the simplest type transforms a reference to the `Source` into a reference to the `Target`.\n\nLet's see how this is used to bind a `Label` view to a string property in the model data.\n\nThs trait has a function which returns some data derived from the\n\nThis trait describes how to extract a reference to some part of the model data. For example, given a reference to the model data, a lens could\n\nThis trait defines a `Source` type and a `Target` type, and a `view` function which, given a reference to the source, returns some output .\n\n## View Binding\n\nSome views accept a [lens](#lenses), as well as a value, as an input. When provided a lens, the view sets up a binding to the data.\n\nFor example, the `Label` view accepts a lens to any type which implements `ToString`:\n\n```rust\n#[derive(Lens)]\npub struct Person {\n    pub name: String,\n}\n\nimpl Model for Person {}\n\nApplication::new(|cx|{\n    Label::new(cx, Person::name);\n})\n.run()\n```\n\nNote the `Lens` derive, which allows us to bind to a field of the model data. When the `name` field changes, the text of the label updates to show the new value.\n\n## The `Binding` View\n\nThere is a special container view in Vizia called the `Binding` view. This view binds to some data and will remove and then rebuild its contents if the data changes.\n\nThe following code produces the same result as passing the lens directly to the label, however, the binding view will rebuild the label when the name changes, which is unnecessary. The binding view is useful for [constructing views conditionally](#conditional-views).\n\n```rust\npub struct Person {\n    pub name: String,\n}\n\nimpl Model for Person {}\n\nApplication::new(|cx|{\n    Binding::new(cx, Person::name, |cx, name|{\n        Label::new(cx, &name.get(cx));\n    });\n})\n.run()\n```\n\n# Lenses\n\nVizia uses lenses to allow specifying a binding to a piece of model data:\n\n```rust\n#[derive(Lens)]\npub struct Person {\n    pub name: String,\n}\n\nimpl Model for Person {}\n```\n\nThe `Lens` derive macro generates a type for each of the fields of the struct.\n\nThen, a static instance of each type is created with the same name as the field, within a module with the same name as the struct.\n\nFor example, for the above model, a lens to the `name` field is created as `Person::name`.\n\nEach generated type implements the `Lens` trait, which looks something like this:\n\n```rust\npub trait Lens {\n    type Source;\n    type Target;\n\n    fn view(&self, &Self::Source) -> &Self::Target;\n}\n```\n\n> NOTE - The above code is a simplification.\n\nThe view method of the lens takes a reference to a `Source` type and produces a reference to a `Target` type. For the `Person::name` lens, the source is `Person` and the target is `String`. The view method, given a reference to `Person`, returns a reference to the `name`.\n\n# Lens Map\n\nThe `map()` method on a lens can be used to derive data from the target of the lens. This is useful for when the lens target is not the right type for the binding, but a value of the correct type can be derived from it.\n\nFor example, let's say we have some string data representing a name in our model, but we only want to display the first letter within a label:\n\n```rust\nuse vizia::prelude::*;\n\n#[derive(Lens)]\npub struct AppData {\n    pub name: String,\n}\n\nimpl Model for AppData {}\n\nfn main() {\n    Application::new(|cx|{\n\n        AppData {\n            name: String::from(\"John Doe\"),\n        }.build(cx);\n\n        Label::new(cx, AppData::name.map(|name| &name[0]));\n    })\n    .inner_size((400, 100))\n    .run();\n}\n```\n\n> Note that in this example we're assuming that the string is not empty.\n\n\u003Cimg src=\"../docs_img/stylesheet.png alt=\"\" width=\"400\"/>\n\nNow when the name field of the model changes the label will update to display the new first letter.\n\n# Property Binding\n\nA property binding updates just the style and layout properties of view in response to model data changes, instead of rebuilding the entire view. Most view modifiers accept a lens as input, which sets up a binding to the target data.\n\nFor example, we can bind the background color of a view, in this case a label, to a color property in the model data using a lens:\n\n```rust\nuse vizia::prelude::*;\n\npub struct AppData {\n    color: Color,\n}\n\nimpl Model for AppData {}\n\nfn main() {\n    Application::new(|cx|{\n        Label::new(cx, \"Colorful\")\n            .background_color(AppData::color);\n    }).run();\n}\n```\n\nMost modifiers accept a lens to a type which can be converted to the expected type. For example, the `text` modifier accepts a lens to any value which implements `ToString`.\n\n# Conditional Views\n\nUsing a `Binding` view a regular `if` statement can be used to conditionally rebuild views.\n\nIn the following example, a label view is built into the tree when a boolean state is true, else the view is removed from the tree.\n\n```rust\nuse vizia::prelude::*;\n\n#[derive(Lens)]\nstruct AppData {\n    show_view: bool,\n}\n\nenum AppEvent {\n    ToggleShowView,\n}\n\nimpl Model for AppData {\n    fn event(&mut self, cx: &mut Context, event: &mut Event) {\n        event.map(|app_event, _| match app_event {\n            AppEvent::ToggleShowView => self.show_view ^= true,\n        });\n    }\n}\n\nfn main() {\n    Application::new(|cx|{\n\n        AppData {\n            show_view: false,\n        }.build(cx);\n\n        Label::new(cx, \"Show View\")\n            .on_press(|cx| cx.emit(AppEvent::ToggleShowView));\n\n        Binding::new(cx, AppData::show_view, |cx, show|{\n            if show.get(cx) {\n                Label::new(cx, \"Surprise!\");\n            }\n        });\n    })\n    .inner_size((400, 100))\n    .run();\n}\n```\n"}</script>
	<script type="application/json" data-sveltekit-fetched data-url="/get-guides">{"status":200,"statusText":"","headers":{},"body":"{\"file_name\":\"guide\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide\",\"link\":\"/guide\",\"is_dir\":true,\"files\":[{\"file_name\":\"introduction\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/introduction\",\"link\":\"/guide/introduction\",\"is_dir\":true,\"files\":[{\"file_name\":\"Foreword\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/introduction/foreword.md\",\"link\":\"/guide/introduction/foreword\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":1}},{\"file_name\":\"Getting started\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/introduction/getting_started.md\",\"link\":\"/guide/introduction/getting_started\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":2}},{\"file_name\":\"Quickstart\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/introduction/quickstart.md\",\"link\":\"/guide/introduction/quickstart\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":3}}],\"meta\":{\"order\":1}},{\"file_name\":\"walkthrough\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/walkthrough\",\"link\":\"/guide/walkthrough\",\"is_dir\":true,\"files\":[{\"file_name\":\"Introduction\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/walkthrough/introduction.md\",\"link\":\"/guide/walkthrough/introduction\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Lenses\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/walkthrough/lenses.md\",\"link\":\"/guide/walkthrough/lenses\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Styling\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/walkthrough/styling.md\",\"link\":\"/guide/walkthrough/styling\",\"is_dir\":false,\"files\":[]}],\"meta\":{\"order\":1}},{\"file_name\":\"basic\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic\",\"link\":\"/guide/basic\",\"is_dir\":true,\"files\":[{\"file_name\":\"Application\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/application.md\",\"link\":\"/guide/basic/application\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":1}},{\"file_name\":\"Views\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/views.md\",\"link\":\"/guide/basic/views\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":2}},{\"file_name\":\"Styling\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/styling.md\",\"link\":\"/guide/basic/styling\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":3}},{\"file_name\":\"Layout\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/layout.md\",\"link\":\"/guide/basic/layout\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":4}},{\"file_name\":\"Models\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/models.md\",\"link\":\"/guide/basic/models\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":5}},{\"file_name\":\"Binding\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/binding.md\",\"link\":\"/guide/basic/binding\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":6}},{\"file_name\":\"Events\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/events.md\",\"link\":\"/guide/basic/events\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":7}},{\"file_name\":\"Custom views\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/custom_views.md\",\"link\":\"/guide/basic/custom_views\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":8}},{\"file_name\":\"Environment\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/environment.md\",\"link\":\"/guide/basic/environment\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":9}},{\"file_name\":\"Resources\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/resources.md\",\"link\":\"/guide/basic/resources\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":10}},{\"file_name\":\"Animation\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/animation.md\",\"link\":\"/guide/basic/animation\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":11}},{\"file_name\":\"Localization\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/localization.md\",\"link\":\"/guide/basic/localization\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":12}},{\"file_name\":\"Accessibility\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/accessibility.md\",\"link\":\"/guide/basic/accessibility\",\"is_dir\":false,\"files\":[],\"meta\":{\"order\":13}},{\"file_name\":\"Keymap\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/keymap.md\",\"link\":\"/guide/basic/keymap\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"List\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/list.md\",\"link\":\"/guide/basic/list\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Overview\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/overview.md\",\"link\":\"/guide/basic/overview\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"View event handling\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/view_event_handling.md\",\"link\":\"/guide/basic/view_event_handling\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"View model data\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/view_model_data.md\",\"link\":\"/guide/basic/view_model_data\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"View tree\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/basic/view_tree.md\",\"link\":\"/guide/basic/view_tree\",\"is_dir\":false,\"files\":[]}],\"meta\":{\"order\":2}},{\"file_name\":\"advanced\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/advanced\",\"link\":\"/guide/advanced\",\"is_dir\":true,\"files\":[{\"file_name\":\"Custom views\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/advanced/custom_views.md\",\"link\":\"/guide/advanced/custom_views\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Localization\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/advanced/localization.md\",\"link\":\"/guide/advanced/localization\",\"is_dir\":false,\"files\":[]}],\"meta\":{\"order\":3}},{\"file_name\":\"SUMMARY\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/SUMMARY.md\",\"link\":\"/guide/SUMMARY\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Architecture\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/architecture.md\",\"link\":\"/guide/architecture\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Index\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/index.md\",\"link\":\"/guide/index\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Intro\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/intro.md\",\"link\":\"/guide/intro\",\"is_dir\":false,\"files\":[]},{\"file_name\":\"Prerequisites\",\"path\":\"/home/lunaesomnia/Documents/GitHub/vizia-site/static/docs/guide/prerequisites.md\",\"link\":\"/guide/prerequisites\",\"is_dir\":false,\"files\":[]}],\"meta\":{\"order\":1}}"}</script></div>
	</body>
</html>
